<!DOCTYPE html>
<html>
<head>
    <link href= "/public/assets/indexStyles.css" rel="stylesheet" type="text/css" />
    <link href="https://fonts.googleapis.com/css2?family=Lobster&display=swap" rel="stylesheet">
   
    <link rel="stylesheet" href="/public/assets/scrollerStyles.css" type="text/css" />
</head>

<body>

    js <%- include('partials/_header') %>

    <div id="scrollerContainer">
        <canvas id="scrollerCanvas" width="800px" height="450px" autofocus></canvas>
    </div>

<script id="main">
    window.addEventListener("load", function(event) {

    "use strict";

        ///////////////////
    //// FUNCTIONS ////
    ///////////////////

    var keyDownUp = function(event) {

    controller.keyDownUp(event.type, event.keyCode);

    };

    var resize = function(event) {

    display.resize(document.documentElement.clientWidth - 32, document.documentElement.clientHeight - 32, game.world.height / game.world.width);
    display.render();

    };

    var render = function() {

    display.drawMap(game.world.map, game.world.columns);
    display.drawPlayer(game.world.player, game.world.player.color1, game.world.player.color2);
    display.render();

    };

    var update = function() {

    if (controller.left.active)  { game.world.player.moveLeft();  }
    if (controller.right.active) { game.world.player.moveRight(); }
    if (controller.up.active)    { game.world.player.jump(); controller.up.active = false; }

    game.update();

    };

        /////////////////
    //// OBJECTS ////
    /////////////////

    var controller = new Controller();
    var display    = new Display(document.querySelector("canvas"));
    var game       = new Game();
    var engine     = new Engine(1000/30, render, update);

        ////////////////////
    //// INITIALIZE ////
    ////////////////////

    display.buffer.canvas.height = game.world.height;
    display.buffer.canvas.width = game.world.width;

    display.tile_sheet.image.addEventListener("load", function(event) {

    resize();

    engine.start();

    }, { once:true });

    display.tile_sheet.image.src = "/public/amns-BG-01.png";

    window.addEventListener("keydown", keyDownUp);
    window.addEventListener("keyup",   keyDownUp);
    window.addEventListener("resize",  resize);
    });
</script>

<script id="controller">

    const Controller = function() {

        this.left  = new Controller.ButtonInput();
        this.right = new Controller.ButtonInput();
        this.up    = new Controller.ButtonInput();

        this.keyDownUp = function(type, key_code) {

            var down = (type == "keydown") ? true : false;

            switch(key_code) {
                case 37: this.left.getInput(down);  break;
                case 38: this.up.getInput(down);    break;
                case 39: this.right.getInput(down);
            }
        };
    };

    Controller.prototype = {
        constructor : Controller
    };

    Controller.ButtonInput = function() {
        this.active = this.down = false;
    };

    Controller.ButtonInput.prototype = {

        constructor : Controller.ButtonInput,

        getInput : function(down) {
            if (this.down != down) this.active = down;
            this.down = down;
        }
    };
</script>

<script id="display">

const Display = function(canvas) {

    this.buffer  = document.createElement("canvas").getContext("2d"),
    this.context = canvas.getContext("2d");

    this.tile_sheet = new Display.TileSheet(16, 8);

    /* This function draws the map to the buffer. */
    this.drawMap = function(map, columns) {

    for (let index = map.length - 1; index > -1; -- index) {

        let value = map[index] - 1;
        let source_x =           (value % this.tile_sheet.columns) * this.tile_sheet.tile_size;
        let source_y = Math.floor(value / this.tile_sheet.columns) * this.tile_sheet.tile_size;
        let destination_x =           (index % columns) * this.tile_sheet.tile_size;
        let destination_y = Math.floor(index / columns) * this.tile_sheet.tile_size;

        this.buffer.drawImage(this.tile_sheet.image, source_x, source_y, this.tile_sheet.tile_size, this.tile_sheet.tile_size, destination_x, destination_y, this.tile_sheet.tile_size, this.tile_sheet.tile_size);

    }

};

    this.drawPlayer = function(rectangle, color1, color2) {

    this.buffer.fillStyle = color1;
    this.buffer.fillRect(Math.floor(rectangle.x), Math.floor(rectangle.y), rectangle.width, rectangle.height);
    this.buffer.fillStyle = color2;
    this.buffer.fillRect(Math.floor(rectangle.x + 2), Math.floor(rectangle.y + 2), rectangle.width - 4, rectangle.height - 4);

    };

    this.resize = function(width, height, height_width_ratio) {

    if (height / width > height_width_ratio) {

        this.context.canvas.height = width * height_width_ratio;
        this.context.canvas.width = width;

    } else {

        this.context.canvas.height = height;
        this.context.canvas.width = height / height_width_ratio;

    }

    this.context.imageSmoothingEnabled = false;

    };

    };

    Display.prototype = {

    constructor : Display,

    render:function() { this.context.drawImage(this.buffer.canvas, 0, 0, this.buffer.canvas.width, this.buffer.canvas.height, 0, 0, this.context.canvas.width, this.context.canvas.height); },

    };

    Display.TileSheet = function(tile_size, columns) {

    this.image = new Image();
    this.tile_size = tile_size;
    this.columns = columns;

    };

    Display.TileSheet.prototype = {};
</script>

<script id="game">
    const Game = function() {

    /* The world object is now its own class. */
    this.world = new Game.World();

    /* The Game.update function works the same as in part 2. */
    this.update = function() {

    this.world.update();

    };

    };

    Game.prototype = { constructor : Game };

    /* The world is now its own class. */
    Game.World = function(friction = 0.9, gravity = 3) {

    this.friction = friction;
    this.gravity  = gravity;

    /* Player is now its own class inside of the Game.World object. */
    this.player   = new Game.World.Player();

    /* Here is the map data. Later on I will load it from a json file, but for now
    I will just hardcode it here. */
    this.columns   = 12;
    this.rows      = 9;
    this.tile_size = 16;
    this.map = [49,18,18,18,50,49,19,20,17,18,36,37, // Tile Map Co-ordinate system 
                11,40,40,40,17,19,40,32,32,32,40,08, // referencing tile number in tile sheet
                11,32,40,32,32,32,40,13,06,06,29,02, // listed here in appearance sequence.
                36,07,40,40,32,40,40,20,40,40,09,10,
                03,32,32,48,40,48,40,32,32,05,37,26,
                11,40,40,32,40,40,40,32,32,32,40,38,
                11,40,32,05,15,07,40,40,04,40,01,43,
                50,03,32,32,12,40,40,32,12,01,43,10,
                09,41,28,14,38,28,14,04,23,35,10,25];

    /* Height and Width now depend on the map size. */
    this.height   = this.tile_size * this.rows;
    this.width    = this.tile_size * this.columns;

    };

    /* Now that world is a class, I moved its more generic functions into its prototype. */
    Game.World.prototype = {

    constructor: Game.World,

    collideObject:function(object) {// Same as in part 2.

    if (object.x < 0) { object.x = 0; object.velocity_x = 0; }
    else if (object.x + object.width > this.width) { object.x = this.width - object.width; object.velocity_x = 0; }
    if (object.y < 0) { object.y = 0; object.velocity_y = 0; }
    else if (object.y + object.height > this.height) { object.jumping = false; object.y = this.height - object.height; object.velocity_y = 0; }

    },

    update:function() {

    this.player.velocity_y += this.gravity;
    this.player.update();

    this.player.velocity_x *= this.friction;
    this.player.velocity_y *= this.friction;

    this.collideObject(this.player);

    }

    };

    /* The player is also its own class now. Since player only appears in the context
    of Game.World, that is where it is defined. */
    Game.World.Player = function(x, y) {

    this.color1     = "#404040";
    this.color2     = "#f0f0f0";
    this.height     = 12;
    this.jumping    = true;
    this.velocity_x = 0;
    this.velocity_y = 0;
    this.width      = 12;
    this.x          = 100;
    this.y          = 50;

    };

    Game.World.Player.prototype = {

    constructor : Game.World.Player,

    jump:function() {

    if (!this.jumping) {

        this.jumping     = true;
        this.velocity_y -= 20;

    }

    },

    moveLeft:function()  { this.velocity_x -= 0.5; },
    moveRight:function() { this.velocity_x += 0.5; },

    update:function() {

    this.x += this.velocity_x;
    this.y += this.velocity_y;

    }

    };
</script>
<script id="engine">
    const Engine = function(time_step, update, render) {

    this.accumulated_time        = 0;// Amount of time that's accumulated since the last update.
    this.animation_frame_request = undefined,// reference to the AFR
    this.time                    = undefined,// The most recent timestamp of loop execution.
    this.time_step               = time_step,// 1000/30 = 30 frames per second

    this.updated = false;// Whether or not the update function has been called since the last cycle.

    this.update = update;// The update function
    this.render = render;// The render function

    this.run = function(time_stamp) {// This is one cycle of the game loop

    this.accumulated_time += time_stamp - this.time;
    this.time = time_stamp;

    /* If the device is too slow, updates may take longer than our time step. If
    this is the case, it could freeze the game and overload the cpu. To prevent this,
    we catch a memory spiral early and never allow three full frames to pass without
    an update. This is not ideal, but at least the user won't crash their cpu. */
    if (this.accumulated_time >= this.time_step * 3) {

        this.accumulated_time = this.time_step;

    }

    /* Since we can only update when the screen is ready to draw and requestAnimationFrame
    calls the run function, we need to keep track of how much time has passed. We
    store that accumulated time and test to see if enough has passed to justify
    an update. Remember, we want to update every time we have accumulated one time step's
    worth of time, and if multiple time steps have accumulated, we must update one
    time for each of them to stay up to speed. */
    while(this.accumulated_time >= this.time_step) {

        this.accumulated_time -= this.time_step;

        this.update(time_stamp);

        this.updated = true;// If the game has updated, we need to draw it again.

    }

    /* This allows us to only draw when the game has updated. */
    if (this.updated) {

        this.updated = false;
        this.render(time_stamp);

    }

    this.animation_frame_request = window.requestAnimationFrame(this.handleRun);

    };

    this.handleRun = (time_step) => { this.run(time_step); };

    };

    Engine.prototype = {

    constructor:Engine,

    start:function() {

    this.accumulated_time = this.time_step;
    this.time = window.performance.now();
    this.animation_frame_request = window.requestAnimationFrame(this.handleRun);

    },

    stop:function() { window.cancelAnimationFrame(this.animation_frame_request); }

    };
</script>

</body>
</html>
