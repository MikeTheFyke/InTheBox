<!DOCTYPE html>
<html>
<head>
    <link href= "/public/assets/indexStyles.css" rel="stylesheet" type="text/css" />
    <link href="https://fonts.googleapis.com/css2?family=Lobster&display=swap" rel="stylesheet">
   
    <link rel="stylesheet" href="/public/assets/scrollerStyles.css" type="text/css" />
</head>

<body>

    js <%- include('partials/_header') %>

    <div id="scrollerContainer">
        <canvas id="scrollerCanvas" width="800px" height="450px" autofocus></canvas>
    </div>

<script id="main">
    window.addEventListener("load", function(event) {

"use strict";

//// CLASSES ////

/* The assets manager will be responsible for loading and storing graphics for
the game. Because it only has to load the tilesheet image right now, it's very specific
about what it does. */
const AssetsManager = function() {

  this.tile_set_image = undefined;

};

AssetsManager.prototype = {

  constructor: Game.AssetsManager,

  loadTileSetImage:function(url, callback) {

    this.tile_set_image = new Image();

    this.tile_set_image.addEventListener("load", function(event) {

      callback();

    }, { once : true});

    this.tile_set_image.src = url;

  }

};

    ///////////////////
  //// FUNCTIONS ////
///////////////////

var keyDownUp = function(event) {

  controller.keyDownUp(event.type, event.keyCode);

};

var resize = function(event) {

  display.resize(document.documentElement.clientWidth, document.documentElement.clientHeight, game.world.height / game.world.width);
  display.render();

};

/* The render function uses the new display methods now. I will eventually have to create
some sort of object manager when I get more objects on the screen. */
var render = function() {

  display.drawMap   (assets_manager.tile_set_image,
  game.world.tile_set.columns, game.world.map, game.world.columns,  game.world.tile_set.tile_size);

  let frame = game.world.tile_set.frames[game.world.player.frame_value];

  display.drawObject(assets_manager.tile_set_image,
  frame.x, frame.y,
  game.world.player.x + Math.floor(game.world.player.width * 0.5 - frame.width * 0.5) + frame.offset_x,
  game.world.player.y + frame.offset_y, frame.width, frame.height);

  display.render();

};

var update = function() {

  if (controller.left.active ) { game.world.player.moveLeft ();                               }
  if (controller.right.active) { game.world.player.moveRight();                               }
  if (controller.up.active   ) { game.world.player.jump();      controller.up.active = false; }

  game.update();

};

    /////////////////
  //// OBJECTS ////
/////////////////

var assets_manager = new AssetsManager();// Behold the new assets manager!
var controller     = new Controller();
var display        = new Display(document.querySelector("canvas"));
var game           = new Game();
var engine         = new Engine(1000/30, render, update);

    ////////////////////
  //// INITIALIZE ////
////////////////////

/* This is going to have to be moved to a setup function inside of the Display class or something.
Leaving it out here is kind of sloppy. */
display.buffer.canvas.height = game.world.height;
display.buffer.canvas.width  = game.world.width;
display.buffer.imageSmoothingEnabled = false;

/* Now my image is loaded into the assets manager instead of the display object.
The callback starts the game engine when the graphic is loaded. */
assets_manager.loadTileSetImage("public/amns-BG-01.png", () => {

  resize();
  engine.start();

});

window.addEventListener("keydown", keyDownUp);
window.addEventListener("keyup",   keyDownUp);
window.addEventListener("resize",  resize);

});
</script>

<script id="controller">

    const Controller = function() {

        this.left  = new Controller.ButtonInput();
        this.right = new Controller.ButtonInput();
        this.up    = new Controller.ButtonInput();

        this.keyDownUp = function(type, key_code) {

            var down = (type == "keydown") ? true : false;

            switch(key_code) {
                case 37: this.left.getInput(down);  break;
                case 38: this.up.getInput(down);    break;
                case 39: this.right.getInput(down);
            }
        };
    };

    Controller.prototype = {
        constructor : Controller
    };

    Controller.ButtonInput = function() {
        this.active = this.down = false;
    };

    Controller.ButtonInput.prototype = {

        constructor : Controller.ButtonInput,

        getInput : function(down) {
            if (this.down != down) this.active = down;
            this.down = down;
        }
    };
</script>

<script id="display">

const Display = function(canvas) {

this.buffer  = document.createElement("canvas").getContext("2d"),
this.context = canvas.getContext("2d");

/* This function draws the map to the buffer. */
this.drawMap = function(image, image_columns, map, map_columns, tile_size) {

  for (let index = map.length - 1; index > -1; -- index) {

    let value         = map[index];
    let source_x      =           (value % image_columns) * tile_size;
    let source_y      = Math.floor(value / image_columns) * tile_size;
    let destination_x =           (index % map_columns  ) * tile_size;
    let destination_y = Math.floor(index / map_columns  ) * tile_size;

    this.buffer.drawImage(image, source_x, source_y, tile_size, tile_size, destination_x, destination_y, tile_size, tile_size);

  }

};

this.drawObject = function(image, source_x, source_y, destination_x, destination_y, width, height) {

  this.buffer.drawImage(image, source_x, source_y, width, height, Math.round(destination_x), Math.round(destination_y), width, height);

};

this.resize = function(width, height, height_width_ratio) {

  if (height / width > height_width_ratio) {

    this.context.canvas.height = width * height_width_ratio;
    this.context.canvas.width  = width;

  } else {

    this.context.canvas.height = height;
    this.context.canvas.width  = height / height_width_ratio;

  }

  this.context.imageSmoothingEnabled = false;

};

};

Display.prototype = {

constructor : Display,

render:function() { this.context.drawImage(this.buffer.canvas, 0, 0, this.buffer.canvas.width, this.buffer.canvas.height, 0, 0, this.context.canvas.width, this.context.canvas.height); },

};
</script>

<script id="game">
    const Game = function() {

this.world    = new Game.World();

this.update   = function() {

  this.world.update();

};

};

Game.prototype = {

constructor : Game,

};

Game.World = function(friction = 0.8, gravity = 2) {

this.collider = new Game.World.Collider();

this.friction = friction;
this.gravity  = gravity;

this.columns   = 12;
this.rows      = 9;

/* Here's where I define the new TileSet class. I give it complete control over
tile_size because there should only be one source for tile_size for both drawing
and collision as this game won't use scaling on individual objects. */
this.tile_set = new Game.World.TileSet(8, 16);
this.player   = new Game.World.Object.Player(100, 100);// The player in its new "namespace".

this.map = [48,17,17,17,49,48,18,19,16,17,35,36,
            10,39,39,39,16,18,39,31,31,31,39,07,
            10,31,39,31,31,31,39,12,05,05,28,01,
            35,06,39,39,31,39,39,19,39,39,08,09,
            02,31,31,47,39,47,39,31,31,04,36,25,
            10,39,39,31,39,39,39,31,31,31,39,37,
            10,39,31,04,14,06,39,39,03,39,00,42,
            49,02,31,31,11,39,39,31,11,00,42,09,
            08,40,27,13,37,27,13,03,22,34,09,24];

this.collision_map = [00,04,04,04,00,00,04,04,04,04,04,00,
                      02,00,00,00,12,06,00,00,00,00,00,08,
                      02,00,00,00,00,00,00,09,05,05,01,00,
                      00,07,00,00,00,00,00,14,00,00,08,00,
                      02,00,00,01,00,01,00,00,00,13,04,00,
                      02,00,00,00,00,00,00,00,00,00,00,08,
                      02,00,00,13,01,07,00,00,11,00,09,00,
                      00,03,00,00,10,00,00,00,08,01,00,00,
                      00,00,01,01,00,01,01,01,00,00,00,00];

this.height   = this.tile_set.tile_size * this.rows;   // these changed to use tile_set.tile_size
this.width    = this.tile_set.tile_size * this.columns;// I got rid of this.tile_size in Game.World

};

Game.World.prototype = {

constructor: Game.World,

collideObject:function(object) {

  if      (object.getLeft()   < 0          ) { object.setLeft(0);             object.velocity_x = 0; }
  else if (object.getRight()  > this.width ) { object.setRight(this.width);   object.velocity_x = 0; }
  if      (object.getTop()    < 0          ) { object.setTop(0);              object.velocity_y = 0; }
  else if (object.getBottom() > this.height) { object.setBottom(this.height); object.velocity_y = 0; object.jumping = false; }

  var bottom, left, right, top, value;

  top    = Math.floor(object.getTop()    / this.tile_set.tile_size);
  left   = Math.floor(object.getLeft()   / this.tile_set.tile_size);
  value  = this.collision_map[top * this.columns + left];
  this.collider.collide(value, object, left * this.tile_set.tile_size, top * this.tile_set.tile_size, this.tile_set.tile_size);

  top    = Math.floor(object.getTop()    / this.tile_set.tile_size);
  right  = Math.floor(object.getRight()  / this.tile_set.tile_size);
  value  = this.collision_map[top * this.columns + right];
  this.collider.collide(value, object, right * this.tile_set.tile_size, top * this.tile_set.tile_size, this.tile_set.tile_size);

  bottom = Math.floor(object.getBottom() / this.tile_set.tile_size);
  left   = Math.floor(object.getLeft()   / this.tile_set.tile_size);
  value  = this.collision_map[bottom * this.columns + left];
  this.collider.collide(value, object, left * this.tile_set.tile_size, bottom * this.tile_set.tile_size, this.tile_set.tile_size);

  bottom = Math.floor(object.getBottom() / this.tile_set.tile_size);
  right  = Math.floor(object.getRight()  / this.tile_set.tile_size);
  value  = this.collision_map[bottom * this.columns + right];
  this.collider.collide(value, object, right * this.tile_set.tile_size, bottom * this.tile_set.tile_size, this.tile_set.tile_size);

},

/* This function changed to update the player's position and then do collision,
and then update the animation based on the player's final condition. */
update:function() {

  this.player.updatePosition(this.gravity, this.friction);

  this.collideObject(this.player);

  this.player.updateAnimation();

}

};

Game.World.Collider = function() {

this.collide = function(value, object, tile_x, tile_y, tile_size) {

  switch(value) {

    case  1: this.collidePlatformTop      (object, tile_y            ); break;
    case  2: this.collidePlatformRight    (object, tile_x + tile_size); break;
    case  3: if (this.collidePlatformTop  (object, tile_y            )) return;// If there's a collision, we don't need to check for anything else.
             this.collidePlatformRight    (object, tile_x + tile_size); break;
    case  4: this.collidePlatformBottom   (object, tile_y + tile_size); break;
    case  5: if (this.collidePlatformTop  (object, tile_y            )) return;
             this.collidePlatformBottom   (object, tile_y + tile_size); break;
    case  6: if (this.collidePlatformRight(object, tile_x + tile_size)) return;
             this.collidePlatformBottom   (object, tile_y + tile_size); break;
    case  7: if (this.collidePlatformTop  (object, tile_y            )) return;
             if (this.collidePlatformRight(object, tile_x + tile_size)) return;
             this.collidePlatformBottom   (object, tile_y + tile_size); break;
    case  8: this.collidePlatformLeft     (object, tile_x            ); break;
    case  9: if (this.collidePlatformTop  (object, tile_y            )) return;
             this.collidePlatformLeft     (object, tile_x            ); break;
    case 10: if (this.collidePlatformLeft (object, tile_x            )) return;
             this.collidePlatformRight    (object, tile_x + tile_size); break;
    case 11: if (this.collidePlatformTop  (object, tile_y            )) return;
             if (this.collidePlatformLeft (object, tile_x            )) return;
             this.collidePlatformRight    (object, tile_x + tile_size); break;
    case 12: if (this.collidePlatformLeft (object, tile_x            )) return;
             this.collidePlatformBottom   (object, tile_y + tile_size); break;
    case 13: if (this.collidePlatformTop  (object, tile_y            )) return;
             if (this.collidePlatformLeft (object, tile_x            )) return;
             this.collidePlatformBottom   (object, tile_y + tile_size); break;
    case 14: if (this.collidePlatformLeft (object, tile_x            )) return;
             if (this.collidePlatformRight(object, tile_x + tile_size)) return; // Had to change this since part 4. I forgot to add tile_size
             this.collidePlatformBottom   (object, tile_y + tile_size); break;
    case 15: if (this.collidePlatformTop  (object, tile_y            )) return;
             if (this.collidePlatformLeft (object, tile_x            )) return;
             if (this.collidePlatformRight(object, tile_x + tile_size)) return;
             this.collidePlatformBottom   (object, tile_y + tile_size); break;

  }

}

};

Game.World.Collider.prototype = {

constructor: Game.World.Collider,

collidePlatformBottom:function(object, tile_bottom) {

  if (object.getTop() < tile_bottom && object.getOldTop() >= tile_bottom) {

    object.setTop(tile_bottom);
    object.velocity_y = 0;
    return true;

  } return false;

},

collidePlatformLeft:function(object, tile_left) {

  if (object.getRight() > tile_left && object.getOldRight() <= tile_left) {

    object.setRight(tile_left - 0.01);
    object.velocity_x = 0;
    return true;

  } return false;

},

collidePlatformRight:function(object, tile_right) {

  if (object.getLeft() < tile_right && object.getOldLeft() >= tile_right) {

    object.setLeft(tile_right);
    object.velocity_x = 0;
    return true;

  } return false;

},

collidePlatformTop:function(object, tile_top) {

  if (object.getBottom() > tile_top && object.getOldBottom() <= tile_top) {

    object.setBottom(tile_top - 0.01);
    object.velocity_y = 0;
    object.jumping    = false;
    return true;

  } return false;

}

};

Game.World.Object = function(x, y, width, height) {

this.height = height;
this.width  = width;
this.x      = x;
this.x_old  = x;
this.y      = y;
this.y_old  = y;

};

Game.World.Object.prototype = {

constructor:Game.World.Object,

/* These functions are used to get and set the different side positions of the object. */
getBottom:   function()  { return this.y     + this.height; },
getLeft:     function()  { return this.x;                   },
getRight:    function()  { return this.x     + this.width;  },
getTop:      function()  { return this.y;                   },
getOldBottom:function()  { return this.y_old + this.height; },
getOldLeft:  function()  { return this.x_old;               },
getOldRight: function()  { return this.x_old + this.width;  },
getOldTop:   function()  { return this.y_old                },
setBottom:   function(y) { this.y     = y    - this.height; },
setLeft:     function(x) { this.x     = x;                  },
setRight:    function(x) { this.x     = x    - this.width;  },
setTop:      function(y) { this.y     = y;                  },
setOldBottom:function(y) { this.y_old = y    - this.height; },
setOldLeft:  function(x) { this.x_old = x;                  },
setOldRight: function(x) { this.x_old = x    - this.width;  },
setOldTop:   function(y) { this.y_old = y;                  }

};

Game.World.Object.Animator = function(frame_set, delay) {

this.count       = 0;
this.delay       = (delay >= 1) ? delay : 1;
this.frame_set   = frame_set;
this.frame_index = 0;
this.frame_value = frame_set[0];
this.mode        = "pause";

};

Game.World.Object.Animator.prototype = {

constructor:Game.World.Object.Animator,

animate:function() {

  switch(this.mode) {

    case "loop" : this.loop(); break;
    case "pause":              break;

  }

},

changeFrameSet(frame_set, mode, delay = 10, frame_index = 0) {

  if (this.frame_set === frame_set) { return; }

  this.count       = 0;
  this.delay       = delay;
  this.frame_set   = frame_set;
  this.frame_index = frame_index;
  this.frame_value = frame_set[frame_index];
  this.mode        = mode;

},

loop:function() {

  this.count ++;

  while(this.count > this.delay) {

    this.count -= this.delay;

    this.frame_index = (this.frame_index < this.frame_set.length - 1) ? this.frame_index + 1 : 0;

    this.frame_value = this.frame_set[this.frame_index];

  }

}

};

/* The player now also extends the Game.World.Object.Animator class. I also added
a direction_x variable to help determine which way the player is facing for animation. */
Game.World.Object.Player = function(x, y) {

Game.World.Object.call(this, 100, 100, 7, 14);
Game.World.Object.Animator.call(this, Game.World.Object.Player.prototype.frame_sets["idle-left"], 10);

this.jumping     = true;
this.direction_x = -1;
this.velocity_x  = 0;
this.velocity_y  = 0;

};

Game.World.Object.Player.prototype = {

constructor:Game.World.Object.Player,

/* The values in these arrays correspond to the TileSet.Frame objects in the tile_set.
They are just hardcoded in here now, but when the tileset information is eventually
loaded from a json file, this will be allocated dynamically in some sort of loading function. */
frame_sets: {

  "idle-left" : [0],
  "jump-left" : [1],
  "move-left" : [2, 3, 4, 5],
  "idle-right": [6],
  "jump-right": [7],
  "move-right": [8, 9, 10, 11]

},

jump: function() {

  if (!this.jumping) {

    this.jumping     = true;
    this.velocity_y -= 20;

  }

},

moveLeft: function() {

  this.direction_x = -1;// Make sure to set the player's direction.
  this.velocity_x -= 0.55;

},

moveRight:function(frame_set) {

  this.direction_x = 1;
  this.velocity_x += 0.55;

},

/* Because animation is entirely dependent on the player's movement at this point,
I made a separate update function just for animation to be called after collision
between the player and the world. This gives the most accurate animations for what
the player is doing movement wise on the screen. */
updateAnimation:function() {

  if (this.velocity_y < 0) {

    if (this.direction_x < 0) this.changeFrameSet(this.frame_sets["jump-left"], "pause");
    else this.changeFrameSet(this.frame_sets["jump-right"], "pause");

  } else if (this.direction_x < 0) {

    if (this.velocity_x < -0.1) this.changeFrameSet(this.frame_sets["move-left"], "loop", 5);
    else this.changeFrameSet(this.frame_sets["idle-left"], "pause");

  } else if (this.direction_x > 0) {

    if (this.velocity_x > 0.1) this.changeFrameSet(this.frame_sets["move-right"], "loop", 5);
    else this.changeFrameSet(this.frame_sets["idle-right"], "pause");

  }

  this.animate();

},

/* This used to be the update function, but now it's a little bit better. It takes
gravity and friction as parameters so the player class can decide what to do with
them. */
updatePosition:function(gravity, friction) {// Changed from the update function

  this.x_old = this.x;
  this.y_old = this.y;
  this.velocity_y += gravity;
  this.x    += this.velocity_x;
  this.y    += this.velocity_y;

  this.velocity_x *= friction;
  this.velocity_y *= friction;

}

};

/* Double prototype inheritance from Object and Animator. */
Object.assign(Game.World.Object.Player.prototype, Game.World.Object.prototype);
Object.assign(Game.World.Object.Player.prototype, Game.World.Object.Animator.prototype);
Game.World.Object.Player.prototype.constructor = Game.World.Object.Player;

/* The TileSheet class was taken from the Display class and renamed TileSet.
It does all the same stuff, but it doesn't have an image reference and it also
defines specific regions in the tile set image that correspond to the player's sprite
animation frames. Later, this will all be set in a level loading function just in case
I want to add functionality to add in another tile sheet graphic with different terrain. */
Game.World.TileSet = function(columns, tile_size) {

this.columns    = columns;
this.tile_size  = tile_size;

let f = Game.World.TileSet.Frame;

/* An array of all the frames in the tile sheet image. */
this.frames = [new f(115,  96, 13, 16, 0, -2), // idle-left
               new f( 50,  96, 13, 16, 0, -2), // jump-left
               new f(102,  96, 13, 16, 0, -2), new f(89, 96, 13, 16, 0, -2), new f(76, 96, 13, 16, 0, -2), new f(63, 96, 13, 16, 0, -2), // walk-left
               new f(  0, 112, 13, 16, 0, -2), // idle-right
               new f( 65, 112, 13, 16, 0, -2), // jump-right
               new f( 13, 112, 13, 16, 0, -2), new f(26, 112, 13, 16, 0, -2), new f(39, 112, 13, 16, 0, -2), new f(52, 112, 13, 16, 0, -2) // walk-right
              ];

};

Game.World.TileSet.prototype = { constructor: Game.World.TileSet };

/* The Frame class just defines a region in a tilesheet to cut out. It's a rectangle.
It has an x and y offset used for drawing the cut out sprite image to the screen,
which allows sprites to be positioned anywhere in the tile sheet image rather than
being forced to adhere to a grid like tile graphics. This is more natural because
sprites often fluctuate in size and won't always fit in a 16x16 grid. */
Game.World.TileSet.Frame = function(x, y, width, height, offset_x, offset_y) {

this.x        = x;
this.y        = y;
this.width    = width;
this.height   = height;
this.offset_x = offset_x;
this.offset_y = offset_y;

};

Game.World.TileSet.Frame.prototype = { constructor: Game.World.TileSet.Frame };
</script>
<script id="engine">
    const Engine = function(time_step, update, render) {

    this.accumulated_time        = 0;// Amount of time that's accumulated since the last update.
    this.animation_frame_request = undefined,// reference to the AFR
    this.time                    = undefined,// The most recent timestamp of loop execution.
    this.time_step               = time_step,// 1000/30 = 30 frames per second

    this.updated = false;// Whether or not the update function has been called since the last cycle.

    this.update = update;// The update function
    this.render = render;// The render function

    this.run = function(time_stamp) {// This is one cycle of the game loop

    this.accumulated_time += time_stamp - this.time;
    this.time = time_stamp;

    /* If the device is too slow, updates may take longer than our time step. If
    this is the case, it could freeze the game and overload the cpu. To prevent this,
    we catch a memory spiral early and never allow three full frames to pass without
    an update. This is not ideal, but at least the user won't crash their cpu. */
    if (this.accumulated_time >= this.time_step * 3) {

        this.accumulated_time = this.time_step;

    }

    /* Since we can only update when the screen is ready to draw and requestAnimationFrame
    calls the run function, we need to keep track of how much time has passed. We
    store that accumulated time and test to see if enough has passed to justify
    an update. Remember, we want to update every time we have accumulated one time step's
    worth of time, and if multiple time steps have accumulated, we must update one
    time for each of them to stay up to speed. */
    while(this.accumulated_time >= this.time_step) {

        this.accumulated_time -= this.time_step;

        this.update(time_stamp);

        this.updated = true;// If the game has updated, we need to draw it again.

    }

    /* This allows us to only draw when the game has updated. */
    if (this.updated) {

        this.updated = false;
        this.render(time_stamp);

    }

    this.animation_frame_request = window.requestAnimationFrame(this.handleRun);

    };

    this.handleRun = (time_step) => { this.run(time_step); };

    };

    Engine.prototype = {

    constructor:Engine,

    start:function() {

    this.accumulated_time = this.time_step;
    this.time = window.performance.now();
    this.animation_frame_request = window.requestAnimationFrame(this.handleRun);

    },

    stop:function() { window.cancelAnimationFrame(this.animation_frame_request); }

    };
</script>

</body>
</html>
